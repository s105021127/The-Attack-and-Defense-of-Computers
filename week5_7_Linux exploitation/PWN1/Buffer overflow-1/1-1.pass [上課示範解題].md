## 題目

Billy left his key in the locked room.
However, he forgot the token of the room.
Do you know what's the key?
(Goal: Print "Door open. OwO")

## 原始碼
```
// pass.c

#include <stdio.h>
#include <stdlib.h>

int main(){
    setvbuf(stdout, 0, 2, 0);
    setvbuf(stdin, 0, 2, 0);
    int token = 1234; // 0x4d2
    char key[16];

    printf("Billy left his key in the locked room.\n");
    printf("However, he forgot the token of the room.\n");
    printf("Do you know what's the key?");

    read(0, key, 40);

    if((int)token == 0xdeadbeef){
        printf("Door open. OwO\n");
        system("cat ./flag");
    }
    else{
        printf("Cannot open door. QwQ\n");
    }

    return 0;
}
```
## 建立pass執行檔
```
gcc -fno-stack-protector -z execstack pass.c -o pass -no-pie
```
在這裡我們需要加上 -fno-stack-protector，**以關閉CANNARY這個記憶體保護機制**

若要遠端測試(remote)連到server，則需要:
```
socat TCP-LISTEN:20000,fork EXEC:'./pass'

```
## 逆向分析
用 radare2 做 static analysis
```
r2 pass
aa
afl
s.main
VV
```
實作結果:
![image](https://user-images.githubusercontent.com/22366572/138507902-21b63d94-7487-4a6d-8f0d-aa5841fdfe21.png)
![image](https://user-images.githubusercontent.com/22366572/138507969-c5d4ed6c-2afe-4af1-a631-5bfc2f4fa053.png)

發現此執行檔的**stack frame**長這樣:
![image](https://user-images.githubusercontent.com/22366572/138508824-013fcb84-eb6f-4f69-83f6-3edad775c7b8.png)

根據 stack frame 我們可以撰寫exploit code

## 撰寫exploit code
![image](https://user-images.githubusercontent.com/22366572/138508233-c427ceba-424f-44dc-a94d-622b12fb82db.png)

## 測試結果成功!
![image](https://user-images.githubusercontent.com/22366572/138508491-704c9888-5fe1-4072-bea6-876b0775d821.png)


